{"version":3,"sources":["taoensso/truss/impl.cljc"],"mappings":"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","names":["taoensso.truss.impl/rsome","pred","coll","cljs.core.reduce","acc","in","temp__5804__auto__","p","cljs.core/reduced","taoensso.truss.impl/revery?","taoensso.truss.impl/revery","taoensso.truss.impl/ensure-set","x","cljs.core/set?","cljs.core/set","ensure-set","taoensso.truss.impl/ks=","ks","m","cljs.core._EQ_","cljs.core/keys","taoensso.truss.impl/ks<=","clojure.set/subset?","taoensso.truss.impl/ks>=","clojure.set/superset?","taoensso.truss.impl/ks-nnil?","p1__28000#","cljs.core.get","taoensso.truss.impl/default-error-fn","data_","cljs.core/deref","data","cljs.core.ex_info","cljs.core.dissoc","taoensso.truss.impl/*data*","taoensso.truss.impl/*error-fn*","taoensso.truss.impl/safe-pred-forms","names","cljs.core.mapv","cljs.core/name","cljs.core.into","p1__28023#","cljs.core.symbol","p1__28024#","taoensso.truss.impl/safe-pred","e28026","js/Error","_","taoensso.truss.impl/error-message","this__5287__auto__","writer__5288__auto__","opt__5289__auto__","cljs.core/-write","taoensso.truss.impl/WrappedError","taoensso.truss.impl/->WrappedError","val","taoensso.truss.impl/-assertion-error","msg","taoensso.truss.impl/-dummy-error","taoensso.truss.impl/-invar-violation!","elidable?","ns-sym","?line","?column","?file","pred-form","pred-rsym","arg-form","arg","?err","?data-fn","error-fn","G__28040","cljs.core/Delay","instant","js/Date","undefn-arg?","arg-val","arg-type","cljs.core/type","msg_","cljs.core/List","temp__5802__auto__","err","err-msg","?data","dynamic","data-fn","e28050","e","or__5002__auto__","loc","v","cljs.core.assoc","output","cljs.core/*assert*"],"sourcesContent":["(ns ^:no-doc taoensso.truss.impl\n  \"Private implementation details.\"\n  (:require\n   [clojure.set :as set]\n   #?(:clj [clojure.java.io :as io]))\n  #?(:cljs (:require-macros [taoensso.truss.impl :refer [catching]])))\n\n(comment (require '[taoensso.encore :as enc]))\n\n;;;; TODO\n;; - Namespaced kw registry like clojure.spec, (truss/def <kw> <pred>)?\n;; - Ideas for easier sharing of composed preds?\n\n;;;; Manual Encore imports\n;; A bit of a nuisance but:\n;;   - Allows Encore to depend on Truss (esp. nb for back-compatibility wrappers).\n;;   - Allows Truss to be entirely dependency free.\n\n#?(:clj\n   (defmacro catching\n     ([try-expr                     ] `(catching ~try-expr ~'_ nil))\n     ([try-expr error-sym catch-expr]\n      (if (:ns &env)\n        `(try ~try-expr (catch js/Error  ~error-sym ~catch-expr))\n        `(try ~try-expr (catch Throwable ~error-sym ~catch-expr))))\n     ([try-expr error-sym catch-expr finally-expr]\n      (if (:ns &env)\n        `(try ~try-expr (catch js/Error  ~error-sym ~catch-expr) (finally ~finally-expr))\n        `(try ~try-expr (catch Throwable ~error-sym ~catch-expr) (finally ~finally-expr))))))\n\n(defn rsome   [pred coll]       (reduce (fn [acc in] (when-let [p (pred in)] (reduced p))) nil coll))\n(defn revery? [pred coll]       (reduce (fn [acc in] (if (pred in) true (reduced nil))) true coll))\n(defn revery  [pred coll] (when (reduce (fn [acc in] (if (pred in) true (reduced nil))) true coll) coll))\n\n(comment (revery integer? [1 2 3]) (revery integer? nil))\n\n(defn ensure-set [x] (if (set? x) x (set x)))\n(let [ensure-set ensure-set]\n  (defn #?(:clj ks=      :cljs ^boolean ks=)      [ks m] (=             (set (keys m)) (ensure-set ks)))\n  (defn #?(:clj ks<=     :cljs ^boolean ks<=)     [ks m] (set/subset?   (set (keys m)) (ensure-set ks)))\n  (defn #?(:clj ks>=     :cljs ^boolean ks>=)     [ks m] (set/superset? (set (keys m)) (ensure-set ks)))\n  (defn #?(:clj ks-nnil? :cljs ^boolean ks-nnil?) [ks m] (revery?     #(some? (get m %))           ks)))\n\n#?(:clj\n   (defn get-source [macro-form macro-env]\n     (let [{:keys [line column file]} (meta macro-form)\n           file\n           (if-not (:ns macro-env)\n             *file* ; Compiling Clj\n             (or    ; Compiling Cljs\n               (when-let [url (and file (catching (io/resource file)))]\n                 (catching (.getPath (io/file url)))\n                 (do                 (str     url)))\n               file))]\n\n       {:ns     (str *ns*)\n        :line   line\n        :column column\n        :file\n        (when (string? file)\n          (when-not (contains? #{\"NO_SOURCE_PATH\" \"NO_SOURCE_FILE\" \"\"} file)\n            file))})))\n\n(comment (io/resource \"taoensso/truss.cljc\"))\n\n#?(:clj\n   (defn- var-info\n     \"Returns ?{:keys [var meta ns name ...]} for given symbol.\"\n     [macro-env sym]\n     (when (symbol? sym)\n       (if (:ns macro-env)\n         (let [ns (find-ns 'cljs.analyzer.api)\n               v  (ns-resolve ns 'resolve)] ; Don't cache!\n           (@v macro-env sym)) ; ?{:keys [meta ns name ...]}\n\n         (when-let [v (resolve macro-env sym)]\n           (let [m (meta v)]\n             {:var v\n              :meta\n              (if-let [x (get m :arglists)]\n                (assoc m :arglists `'~x) ; Quote\n                (do    m))\n\n              :ns   (get m :ns)\n              :name (get m :name)}))))))\n\n#?(:clj\n   (defn resolve-sym [macro-env sym]\n     (when (symbol? sym)\n       (when-let [{var-ns :ns, var-name :name} (var-info macro-env sym)]\n         (symbol (str var-ns) (name var-name))))))\n\n(comment (resolve-sym nil 'string?))\n\n;;;; Truss\n\n(defn default-error-fn [data_]\n  (let [data @data_]\n    (throw (ex-info @(:msg_ data) (dissoc data :msg_)))))\n\n(def ^:dynamic *data* nil)\n(def ^:dynamic *error-fn* default-error-fn)\n\n(def ^:private safe-pred-forms\n  (let [names\n        (mapv name\n          '#{nil? some? string? integer? number? symbol? keyword? float?\n             set? vector? coll? list? ifn? fn? associative? sequential? delay?\n             sorted? counted? reversible? true? false? identity not boolean})]\n\n    (-> #{}\n      (into (mapv #(symbol \"clojure.core\" %) names))\n      (into (mapv #(symbol    \"cljs.core\" %) names)))))\n\n(defn safe-pred [pred] (fn [x] (catching (pred x))))\n#?(:clj\n   (defn- safe-pred-form?\n     \"Returns true for common preds that can't throw.\"\n     [macro-env pred-form]\n     (or\n       (keyword? pred-form)\n       (map?     pred-form)\n       (set?     pred-form)\n       (when-let [rsym (resolve-sym macro-env pred-form)]\n         (contains? safe-pred-forms rsym)))))\n\n(comment (safe-pred-form? nil 'nil?))\n\n#?(:clj\n   (defn parse-pred-form\n     \"Returns {:keys [pred rsym safe?]}\"\n     [macro-env pred-form]\n     (cond\n       (= pred-form ::some?) (parse-pred-form macro-env `some?)\n       (not (vector? pred-form))\n       {:pred-form                        pred-form\n        :rsym  (resolve-sym     macro-env pred-form)\n        :safe? (safe-pred-form? macro-env pred-form)}\n\n       :else\n       (let [[type a1 a2 a3]      pred-form\n             num-args (dec (count pred-form))]\n\n         (when (or (< num-args 1) (> num-args 3))\n           (throw\n             (ex-info \"Truss special predicates should have 1\u2264n\u22643\"\n               {:pred-form pred-form})))\n\n         (case type\n           :set=             {:pred-form `(fn [~'x] (=             (ensure-set ~'x) (ensure-set ~a1)))}\n           :set<=            {:pred-form `(fn [~'x] (set/subset?   (ensure-set ~'x) (ensure-set ~a1)))}\n           :set>=            {:pred-form `(fn [~'x] (set/superset? (ensure-set ~'x) (ensure-set ~a1)))}\n\n           :ks=              {:pred-form `(fn [~'x] (ks=      ~a1 ~'x))}\n           :ks<=             {:pred-form `(fn [~'x] (ks<=     ~a1 ~'x))}\n           :ks>=             {:pred-form `(fn [~'x] (ks>=     ~a1 ~'x))}\n           :ks-nnil?         {:pred-form `(fn [~'x] (ks-nnil? ~a1 ~'x))}\n           (    :el     :in) {:pred-form `(fn [~'x]      (contains? (ensure-set ~a1) ~'x))}\n           (:not-el :not-in) {:pred-form `(fn [~'x] (not (contains? (ensure-set ~a1) ~'x)))}\n\n           :n=               {:pred-form `(fn [~'x] (=  (count ~'x) ~a1))}\n           :n>=              {:pred-form `(fn [~'x] (>= (count ~'x) ~a1))}\n           :n<=              {:pred-form `(fn [~'x] (<= (count ~'x) ~a1))}\n\n           :instance?        {:pred-form `(fn [~'x] (instance?  ~a1 ~'x))}\n           :satisfies?       {:pred-form `(fn [~'x] (satisfies? ~a1 ~'x))}\n\n           (:and :or :not) ; Composition\n           (let [;;; Support recursive expansion\n                 {a1 :pred-form, sf-a1? :safe?} (when a1 (parse-pred-form macro-env a1))\n                 {a2 :pred-form, sf-a2? :safe?} (when a2 (parse-pred-form macro-env a2))\n                 {a3 :pred-form, sf-a3? :safe?} (when a3 (parse-pred-form macro-env a3))\n\n                 sf-a1    (when a1 (if sf-a1? a1 `(safe-pred ~a1)))\n                 sf-a2    (when a2 (if sf-a2? a2 `(safe-pred ~a2)))\n                 sf-a3    (when a3 (if sf-a3? a3 `(safe-pred ~a3)))\n                 sf-comp? (cond a3 (and sf-a1? sf-a2? sf-a3?)\n                                a2 (and sf-a1? sf-a2?)\n                                a1      sf-a1?)]\n\n             (case type\n               :and ; all-of\n               (cond\n                 a3 {:safe? sf-comp?, :pred-form `(fn [~'x] (and (~a1 ~'x) (~a2 ~'x) (~a3 ~'x)))}\n                 a2 {:safe? sf-comp?, :pred-form `(fn [~'x] (and (~a1 ~'x) (~a2 ~'x)))}\n                 a1 {:safe? sf-a1?,   :pred-form a1})\n\n               :or ; any-of\n               (cond\n                 a3 {:safe? true,   :pred-form `(fn [~'x] (or (~sf-a1 ~'x) (~sf-a2 ~'x) (~sf-a3 ~'x)))}\n                 a2 {:safe? true,   :pred-form `(fn [~'x] (or (~sf-a1 ~'x) (~sf-a2 ~'x)))}\n                 a1 {:safe? sf-a1?, :pred-form a1})\n\n               :not ; complement/none-of\n               ;; It's unclear if we'd want safe (non-throwing) behaviour here,\n               ;; so will nterpret throws as undefined to minimize surprize\n               (cond\n                 a3 {:safe? sf-comp?, :pred-form `(fn [~'x] (not (or (~a1 ~'x) (~a2 ~'x) (~a3 ~'x))))}\n                 a2 {:safe? sf-comp?, :pred-form `(fn [~'x] (not (or (~a1 ~'x) (~a2 ~'x))))}\n                 a1 {:safe? sf-a1?,   :pred-form `(fn [~'x] (not     (~a1 ~'x)))})))\n\n           (throw (ex-info \"Unexpected Truss special predicate type\"\n                    {:pred-form pred-form})))))))\n\n(comment\n  [(parse-pred-form nil ::some?)\n   (parse-pred-form nil 'string?)\n   (parse-pred-form nil 'seq)\n   (parse-pred-form nil [:or  'string? 'seq])\n   (parse-pred-form nil [:and 'string? 'integer?])\n   (parse-pred-form nil [:and 'string? 'seq])\n   (parse-pred-form nil [:and 'integer? [:and 'number? 'pos? 'int?]])])\n\n(defn- error-message\n  ;; Temporary, to support Clojure 1.9\n  ;; Clojure 1.10+ now has `ex-message`\n  [x]\n  #?(:clj  (when (instance? Throwable x) (.getMessage ^Throwable x))\n     :cljs (when (instance? js/Error  x) (.-message              x))))\n\n(deftype WrappedError [val])\n(defn -assertion-error [msg] #?(:clj (AssertionError. msg) :cljs (js/Error. msg)))\n(def  -dummy-error #?(:clj (Object.) :cljs (js-obj)))\n(defn -invar-violation!\n  [elidable? ns-sym ?line ?column ?file pred-form pred-rsym arg-form arg ?err ?data-fn]\n  (when-let [error-fn *error-fn*]\n    (error-fn ; Nb consumer must deref while bindings are still active\n     (delay\n      (let [instant     #?(:clj (java.util.Date.) :cljs (js/Date.))\n            undefn-arg? (instance? WrappedError arg)\n            arg-val     (if undefn-arg? 'truss/undefined-arg       arg)\n            arg-type    (if undefn-arg? 'truss/undefined-arg (type arg))\n\n            ?err\n            (cond\n              (identical? -dummy-error ?err) nil\n              (instance?  WrappedError ?err)\n              (.-val     ^WrappedError ?err)\n              :else                    ?err)\n\n            msg_\n            (delay\n              (let [; arg-form (if (nil? arg-form) 'nil arg-form)\n                    msg\n                    (str \"Invariant failed at \" ns-sym\n                      (when ?line (str \"[\" ?line (when ?column (str \",\" ?column)) \"]\")) \": \"\n                      (list pred-form arg-form #_arg-val))]\n\n                (if-let [err ?err]\n                  (let [err-msg #_(ex-message err) (error-message err)]\n                    (if undefn-arg?\n                      (str msg \"\\r\\n\\r\\nError evaluating arg: \"  err-msg)\n                      (str msg \"\\r\\n\\r\\nError evaluating pred: \" err-msg)))\n                  msg)))\n\n            ?data\n            (let [dynamic *data*\n                  arg\n                  (when-let [data-fn ?data-fn]\n                    (catching (data-fn) e\n                      {:truss/error e}))]\n\n              (when (or   dynamic      arg)\n                {:dynamic dynamic :arg arg}))\n\n            loc {:ns ns-sym}\n            loc (if-let [v ?line]   (assoc loc :line   v) loc)\n            loc (if-let [v ?column] (assoc loc :column v) loc)\n            loc (if-let [v ?file]   (assoc loc :file   v) loc)\n\n            output\n            {:msg_ msg_\n             :dt   instant\n             :pred (or pred-rsym pred-form)\n             :arg  {:form      arg-form\n                    :value     arg-val\n                    :type      arg-type}\n             :env  {:elidable? elidable?\n                    :*assert*  *assert*}\n             :loc  loc}\n\n            output (if-let [v ?data] (assoc output :data v) output)\n            output (if-let [v ?err]  (assoc output :err  v) output)]\n\n        output)))))\n\n#?(:clj\n   (defn const-form? \"See issue #12\" [x]\n     (not (or (list? x) (instance? clojure.lang.Cons x)))))\n\n#?(:clj\n   (defmacro -invar\n     \"Written to maximize performance + minimize post Closure+gzip Cljs code size.\"\n     [elidable? truthy? source pred-form x ?data-fn]\n     (let [const-x? (const-form? x) ; Common case\n\n           {:keys [ns line column file]} source\n           ns-sym (symbol ns)\n\n           {pred-form* :pred-form,\n            pred-safe? :safe?,\n            pred-rsym  :rsym} (parse-pred-form &env pred-form)]\n\n       (if const-x? ; Common case\n         (if pred-safe? ; Common case\n           `(if (~pred-form* ~x)\n              ~(if truthy? true x)\n              (-invar-violation! ~elidable? '~ns-sym ~line ~column ~file '~pred-form '~pred-rsym '~x ~x nil ~?data-fn))\n\n           `(let [~'e (catching (if (~pred-form* ~x) nil -dummy-error) ~'e ~'e)]\n              (if (nil? ~'e)\n                ~(if truthy? true x)\n                (-invar-violation! ~elidable? '~ns-sym ~line ~column ~file '~pred-form '~pred-rsym '~x ~x ~'e ~?data-fn))))\n\n         (if pred-safe?\n           `(let [~'z (catching ~x ~'e (WrappedError. ~'e))\n                  ~'e (if (instance? WrappedError ~'z)\n                        ~'z\n                        (if (~pred-form* ~'z) nil -dummy-error))]\n\n              (if (nil? ~'e)\n                ~(if truthy? true 'z)\n                (-invar-violation! ~elidable? '~ns-sym ~line ~column ~file '~pred-form '~pred-rsym '~x ~'z ~'e ~?data-fn)))\n\n           `(let [~'z (catching ~x ~'e (WrappedError. ~'e))\n                  ~'e (catching\n                        (if (instance? WrappedError ~'z)\n                          ~'z\n                          (if (~pred-form* ~'z) nil -dummy-error)) ~'e ~'e)]\n\n              (if (nil? ~'e)\n                ~(if truthy? true 'z)\n                (-invar-violation! ~elidable? '~ns-sym ~line ~column ~file '~pred-form '~pred-rsym '~x ~'z ~'e ~?data-fn))))))))\n\n(comment\n  (macroexpand '(-invar true false 1      string?    \"foo\"             nil)) ; Type 0\n  (macroexpand '(-invar true false 1 [:or string?]   \"foo\"             nil)) ; Type 0\n  (macroexpand '(-invar true false 1    #(string? %) \"foo\"             nil)) ; Type 1\n  (macroexpand '(-invar true false 1      string?    (str \"foo\" \"bar\") nil)) ; Type 2\n  (macroexpand '(-invar true false 1    #(string? %) (str \"foo\" \"bar\") nil)) ; Type 3\n  (enc/qb 1e6\n    (string? \"foo\")                                          ; Baseline\n    (-invar true false 1   string?    \"foo\"             nil) ; Type 0\n    (-invar true false 1 #(string? %) \"foo\"             nil) ; Type 1\n    (-invar true false 1   string?    (str \"foo\" \"bar\") nil) ; Type 2\n    (-invar true false 1 #(string? %) (str \"foo\" \"bar\") nil) ; Type 3\n    (try\n      (string? (try \"foo\" (catch Throwable _ nil)))\n      (catch Throwable _ nil)))\n  ;; [41.86 50.43 59.56 171.12 151.2 42.0]\n\n  (-invar false false 1 integer? \"foo\"   nil) ; Pred failure example\n  (-invar false false 1 zero?    \"foo\"   nil) ; Pred error example\n  (-invar false false 1 zero?    (/ 5 0) nil) ; Form error example\n  )\n\n#?(:clj\n   (defmacro -invariant [elidable? truthy? source args]\n     (let [bang?      (= (first args) :!) ; For back compatibility, undocumented\n           elidable?  (and elidable? (not bang?))\n           elide?     (and elidable? (not *assert*))\n           args       (if bang? (next args) args)\n           in?        (= (second args) :in) ; (have pred :in xs1 xs2 ...)\n           args       (if in? (cons (first args) (nnext args)) args)\n\n           data?      (and (> (count args) 2) ; Distinguish from `:data` pred\n                           (= (last (butlast args)) :data))\n           ?data-fn   (when data? `(fn [] ~(last args)))\n           args       (if data? (butlast (butlast args)) args)\n\n           auto-pred? (= (count args) 1) ; Unique common case: (have ?x)\n           pred       (if auto-pred? ::some? (first args))\n           [?x1 ?xs]  (if auto-pred?\n                        [(first args) nil]\n                        (if (nnext args) [nil (next args)] [(second args) nil]))\n           single-x?  (nil? ?xs)\n           in-fn\n           `(fn [~'__in] ; Will (necessarily) lose exact form\n              (-invar ~elidable? ~truthy? ~source ~pred ~'__in ~?data-fn))]\n\n       (if elide?\n         (if truthy?\n           true\n           (if single-x? ?x1 (vec ?xs)))\n\n         (if-not in?\n\n           (if single-x?\n             ;; (have pred x) -> x\n             `(-invar ~elidable? ~truthy? ~source ~pred ~?x1 ~?data-fn)\n\n             ;; (have pred x1 x2 ...) -> [x1 x2 ...]\n             (if truthy?\n               `(do ~@(mapv (fn [x] `(-invar ~elidable? ~truthy? ~source ~pred ~x ~?data-fn)) ?xs) true)\n               (do    (mapv (fn [x] `(-invar ~elidable? ~truthy? ~source ~pred ~x ~?data-fn)) ?xs))))\n\n           (if single-x?\n\n             ;; (have? pred :in xs) -> bool\n             ;; (have  pred :in xs) -> xs\n             (if truthy?\n               `(revery? ~in-fn ~?x1)\n               `(revery  ~in-fn ~?x1))\n\n             ;; (have? pred :in xs1 xs2 ...) -> [bool1 ...]\n             ;; (have  pred :in xs1 xs2 ...) -> [xs1   ...]\n             (if truthy?\n               `(do ~@(mapv (fn [xs] `(revery? ~in-fn ~xs)) ?xs) true)\n               (do    (mapv (fn [xs] `(revery  ~in-fn ~xs)) ?xs)))))))))\n"],"x_google_ignoreList":[0]}