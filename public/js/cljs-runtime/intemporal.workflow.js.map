{"version":3,"sources":["intemporal/workflow.cljc"],"mappings":"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","names":["intemporal.workflow/current-workflow-run","intemporal.workflow/current-workflow-id","intemporal.error/workflow-error","intemporal.utils.string.fmt","intemporal.workflow.execution/-workflow-id","intemporal.workflow/current-workflow-runid","intemporal.workflow.execution/-workflow-runid","intemporal.workflow/save-workflow-event","event-type","payload","intemporal.workflow.execution/-save-workflow-event!","intemporal.workflow/save-activity-event","activity-id","intemporal.workflow.execution/-save-activity-event!","intemporal.workflow/next-event","nxt","intemporal.workflow.execution/-next-event","intemporal.workflow/current-event","intemporal.workflow.execution/-current-event","intemporal.workflow/event-matches?","uid","match?","cljs.core._EQ_","taoensso.timbre._log_BANG_","taoensso.timbre/*config*","cljs.core/Delay","intemporal.workflow/delete-history-forward","intemporal.workflow.execution/-delete-history-forward","intemporal.workflow/advance-history-cursor","intemporal.workflow.execution/-advance-history-cursor","intemporal.workflow/add-compensation","f","intemporal.workflow.execution/-add-compensation","intemporal.workflow/cljs-available?","intemporal.workflow/compensate","actions","intemporal.workflow.execution/-workflow-compensations","seq__42853","cljs.core/seq","chunk__42854","count__42855","i__42856","temp__5804__auto__","cljs.core/chunked-seq?","c__5568__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","cljs.core/first","cljs.core/next","compensation","intemporal.workflow/retry","store","runid","vec__42857","cljs.core.nth","wid","_wvar","intemporal.store/find-workflow","current-workflow-run-orig-val__42860","current-workflow-run-temp-val__42861","intemporal.workflow.execution.make_workflow_execution","invoke-evt","cljs.core.ex_info","intemporal.workflow.execution/-reset-history-cursor","cljs.core.apply","intemporal.workflow/sym->workflow-id","sym","cljs.core.symbol","cljs.core/ns-name","cljs.core/*ns*","intemporal.workflow/proxy-workflow-fn","astore","args","current-workflow-run-orig-val__42862","current-workflow-run-temp-val__42863","or__5045__auto__","vargs","cljs.core.into","e42864","result","js/Error","e"],"sourcesContent":["(ns intemporal.workflow\n  \"Main namespace. A worfklow definition is a function that is proxied to save its arguments and result/error.\"\n  (:require [intemporal.store :as s]\n            [intemporal.workflow.execution :as e]\n            [intemporal.utils.check :refer [check]]\n            [intemporal.utils.string :refer [fmt]]\n            [taoensso.timbre :as log :refer [log]])\n  #?(:clj (:require [net.cgrand.macrovich :as macros])\n     :cljs (:require-macros [net.cgrand.macrovich :as macros]\n                            [intemporal.workflow :refer [register-workflow]])))\n\n;; holds the data for the current workflow, including the store used for persistence\n;; is a dynamic var so we can rebind each time the workflow function is called\n(def ^:dynamic current-workflow-run nil)\n\n;; current workflow accessors\n(defn current-workflow-id []\n  (check (some? current-workflow-run) \"Not running within a workflow function, did you call `register-workflow`?\")\n  (e/-workflow-id current-workflow-run))\n\n(defn current-workflow-runid []\n  (check (some? current-workflow-run) \"Not running within a workflow function, did you call `register-workflow`?\")\n  (e/-workflow-runid current-workflow-run))\n\n(defn save-workflow-event [event-type payload]\n  (check (some? current-workflow-run) \"Not running within a workflow function, did you call `register-workflow`?\")\n  (e/-save-workflow-event! current-workflow-run event-type payload))\n\n(defn save-activity-event [activity-id event-type payload]\n  (check (some? current-workflow-run) \"Not running within a workflow function, did you call `register-workflow`?\")\n  (e/-save-activity-event! current-workflow-run activity-id event-type payload))\n\n(defn next-event []\n  (check (some? current-workflow-run) \"Not running within a workflow function, did you call `register-workflow`?\")\n  (let [nxt (e/-next-event current-workflow-run)]\n    nxt))\n\n(defn current-event []\n  (check (some? current-workflow-run) \"Not running within a workflow function, did you call `register-workflow`?\")\n  (let [nxt (e/-current-event current-workflow-run)]\n    nxt))\n\n(defn event-matches? [nxt uid event-type]\n  (check (some? current-workflow-run) \"Not running within a workflow function, did you call `register-workflow`?\")\n  (let [match? (and (some? nxt)\n                    (= (:type nxt) event-type)\n                    (= (:uid nxt) uid))]\n    (log/debugf \"[store] match? %s [%s %s]\" match? event-type uid)\n    match?))\n\n(defn delete-history-forward []\n  (check (some? current-workflow-run) \"Not running within a workflow function, did you call `register-workflow`?\")\n  (e/-delete-history-forward current-workflow-run))\n\n(defn advance-history-cursor []\n  (check (some? current-workflow-run) \"Not running within a workflow function, did you call `register-workflow`?\")\n  (e/-advance-history-cursor current-workflow-run))\n\n(defn add-compensation [f]\n  (check (some? current-workflow-run) \"Not running within a workflow function, did you call `register-workflow`?\")\n  (e/-add-compensation current-workflow-run f))\n\n;;;;\n;;\n\n\n(def cljs-available?\n  #?(:cljs\n     false\n     :clj\n     (try\n       (require '[cljs.analyzer])\n       ;; Ensure clojurescript is recent enough:\n       (-> 'cljs.analyzer/var-meta resolve boolean)\n       (catch Exception _ false))))\n\n\n\n(defn compensate\n  \"Calls all compensation functions in order.\n  If any compensation function fails, the remaining functions will NOT be called.\"\n  []\n  (check (some? current-workflow-run) \"Not running within a workflow function, did you call `register-workflow`?\")\n  (let [actions (e/-workflow-compensations current-workflow-run)]\n    (doseq [compensation actions]\n      (compensation))))\n\n(defn retry\n  \"Retries `f` with given `runid`, possibly resuming execution if `f` didn't reach a terminal state.\"\n  [store f runid]\n  (let [[wid _wvar] (s/find-workflow store runid)]\n    (check (some? wid) \"No workflow found for runid %s\" runid)\n    ;; TODO: check if the workflow reached a terminal state yet\n    (binding [current-workflow-run (e/make-workflow-execution store wid runid)]\n      (let [invoke-evt (e/-advance-history-cursor current-workflow-run)]\n        (when-not (some? invoke-evt)\n          (throw (ex-info (fmt \"%s: runid %s not found\" wid runid) {})))\n\n        (when-not (= (:type invoke-evt) ::invoke)\n          (throw (ex-info (fmt \"%s: event for run %s is %s, should be ::invoke\" wid invoke-evt runid) {})))\n\n        (e/-reset-history-cursor current-workflow-run)\n        (apply f (:payload invoke-evt))))))\n\n;;;;\n;; worfklow is just a function\n\n(defn- sym->workflow-id [sym]\n  (symbol (str (ns-name *ns*)) (str sym)))\n\n(defn proxy-workflow-fn\n  [astore wid f args]\n  (binding [current-workflow-run (or current-workflow-run (e/make-workflow-execution astore wid))]\n    (let [vargs (if (event-matches? (next-event) wid ::invoke)\n                  (:payload (advance-history-cursor))\n                  (do\n                    (save-workflow-event ::invoke args)\n                    (into [] args)))]\n      (try\n        (let [result (apply f vargs)\n              nxt    (next-event)]\n          ;; if it throws we go to the catch\n          (cond\n            (event-matches? nxt wid ::success)\n            (:payload (advance-history-cursor))\n\n            (event-matches? nxt wid ::failure)\n            (throw (:payload (advance-history-cursor)))     ;; goes to catch\n\n            ;; TODO handle divergence\n            :else\n            (do\n              (save-workflow-event ::success result)\n              result)))\n        (catch #?(:clj Exception :cljs js/Error) e\n          ;; did we just replay a throw?\n          ;; TODO should match the exception too?\n          (if (event-matches? (next-event) wid ::failure)\n            (:payload (advance-history-cursor))\n            (do\n              (save-workflow-event ::failure e)\n              (throw e))))))))\n\n(defmacro register-workflow\n  \"Registers function `fsym`, using `store` to keep track of executions.\n  Replaces the function var by a proxy that saves execution to the store.\"\n  [store fsym]\n  ;; TODO: throw if already registered\n  (macros/case\n    :cljs\n    (when cljs-available?\n      (let [analyzer (find-ns 'cljs.analyzer)\n            resolved ((ns-resolve analyzer 'resolve-var) &env fsym)\n            fname    (str (:name resolved))\n            ;fname    (str fsym)\n            wid      fname] ;(sym->workflow-id fname)\n        `(let [f#       ~fsym\n               proxied# (fn proxy-workflow# [& args#]\n                          (proxy-workflow-fn ~store '~wid f# args#))]\n           (set! ~fsym proxied#)\n           (do\n             (check (cljs.core/satisfies? s/WorkflowStore ~store) \"store %s does not implement WorkflowStore\" (s/id ~store))\n             ;(s/save-workflow-definition ~store '~wid proxied#)\n             (s/save-workflow-definition ~store '~wid ~fname)\n             nil))))\n\n    :clj\n    (let [fvar   (resolve fsym)\n          wid    (sym->workflow-id fsym)\n          astore (var-get (resolve store))]\n      (check (bound? fvar) \"%s: Should be bound\" fsym)\n      (alter-var-root fvar\n        (fn [f]\n          (fn proxy-workflow [& args]\n            ;; the current-workflow-run will hold the store where all data will be saved\n            (proxy-workflow-fn astore wid f args))))\n\n      `(do\n         (check (satisfies? s/WorkflowStore ~store) \"store %s does not implement WorkflowStore\" (s/id ~store))\n         (s/save-workflow-definition ~store '~wid ~fvar)\n         nil))))\n\n\n"]}