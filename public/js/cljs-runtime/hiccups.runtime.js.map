{"version":3,"sources":["hiccups/runtime.cljs"],"mappings":";AAGA;;;yBAAA,zBACEA;AAEF;;;oCAAA,2CAAA,IAAA,QAAA,IAAA,OAAA,IAAA,OAAA,KAAA,tHACEC;AAEF;;;iCAAA,kFAAA,aAAA,cAAA,YAAA,UAAA,UAAA,aAAA,gBAAA,YAAA,UAAA,cAAA,UAAA,UAAA,aAAA,YAAA,cAAA,UAAA,UAAA,SAAA,YAAA,gBAAA,SAAA,WAAA,SAAA,UAAA,WAAA,UAAA,cAAA,cAAA,YAAA,UAAA,UAAA,UAAA,reACEC;AAKF,yBAAA,zBAAMC,0DAAQC;AAAd,AACE,GAAI,EAAI,cAAAC,bAAUD,qCAAG,cAAAE,bAASF;AAC5B,OAACG,eAAKH;;AACN,mDAAKA;;;AAET,wCAAA,xCAAeI;AAEf,kCAAA,lCAAOC;AAAP,AACE,0FAAA,nFAACC,6CAAEF;;AAEL,0BAAA,1BAAMG,4DAASC,KAAKC;AAApB,AACE,IAAAC,wCAAUN;IAAVO,wCAAsBH;AAAtB,AAAA,yCAAAG,xCAAUP;;AAAV,IAAA,AACE,QAACK,kCAAAA,oCAAAA;UADH,AAAA,yCAAAC,xCAAUN;;AAGZ;;;8BAAA,9BAAMQ,oEAEHC;AAFH,6BAGM,AAACd,uBAAOc,pDACR,OAACC,mDAAejB;;AAEtB,AAAKkB,oBAAEH;AAEP,0BAAA,1BAAMI;AAAN,AACE,GAAI,AAACX;AAAL;;AAAA;;;AAEF,gCAAA,hCAAMY,wEAAeC,KAAKC;AAA1B,AACE,QAAA,iCAAA,yCAAA,tEAAS,AAACpB,uBAAOmB,YAAY,AAACN,4BAAYO;;AAE5C,mCAAA,2CAAAC,9EAAMG;AAAN,AAAA,IAAAF,aAAAD;WAAA,AAAAE,4CAAAD,WAAA,IAAA,lEAAyBH;YAAzB,AAAAI,4CAAAD,WAAA,IAAA,nEAA8BF;AAA9B,AACE,GACE,AAAOA;AACL,GAAI,AAACd;AACD,OAACY,8BAAcC,KAAKA;;AACpB,QAAA,IAAS,AAACnB,uBAAOmB;;;AAJzB,GAKE,AAACM,cAAIL;AALP;;AAAA,AAQI,OAACF,8BAAcC,KAAKC;;;;;AAE1B,kCAAA,lCAAMM,4EAAiBC;AAAvB,AACE,OAACC,8CAAMC,cACL,AAACC,6CAAK,AAACC,4CAAIP,iCAAiBG;;AAEhC;;;oCAAA,4CAAAK,hFAAMO;AAAN,AAAA,IAAAN,aAAAD;IAAAE,aAAA,AAAAC,cAAAF;IAAAG,eAAA,AAAAC,gBAAAH;IAAAA,iBAAA,AAAAI,eAAAJ;UAAAE,NAEII;cAFJN,VAEUO;AAFV,AAGE,GAAM,GAAK,0CAAA,xCAAI,gBAAAvC,fAAUsC,yCAAK,gBAAArC,fAASqC,sCAAK,OAASA;AAArD,AACE,MAAO,kDAAA,LAAKA;;AADd;;AAEA,IAAAE,aAAuB,AAACI,qBAAWjD,uBAAO,AAACG,uBAAOwC;QAAlD,AAAAjB,4CAAAmB,WAAA,IAAA,/DAAOC;cAAP,AAAApB,4CAAAmB,WAAA,IAAA,rEAASF;SAAT,AAAAjB,4CAAAmB,WAAA,IAAA,hEAAaE;aAAb,AAAArB,4CAAAmB,WAAA,IAAA,pEAAgBG;gBAAhB,2CAAA,qDAAA,5GACME,yGAAsBH,2DACG,iEAAA,/CAAIC,QAAM,8BAAA,IAAA,lCAACG,uBAAgBH;IACpDI,YAAiB,AAACZ,gBAAMI;AAH9B,AAIE,GAAI,AAACS,qBAAKD;AAAV,0FACGT,QAAI,AAACW,uGAAMJ,UAAUE,gBAAW,AAACX,eAAKG;;AADzC,0FAEGD,QAAIO,UAAUN;;;AAErB,AAAA,AAEA;;;iCAAA,jCAAMW,0EAEHC;AAFH,AAGE,IAAAC,aAA0B,AAACf,kCAAkBc;UAA7C,AAAA9B,4CAAA+B,WAAA,IAAA,jEAAOd;YAAP,AAAAjB,4CAAA+B,WAAA,IAAA,nEAAW3B;cAAX,AAAAJ,4CAAA+B,WAAA,IAAA,rEAAiBb;AAAjB,AACE,oBAAI,iBAAAc,mBAAId;AAAJ,AAAA,oBAAAc;AAAAA;;AAAY,QAACxD,+DAAAA,oEAAAA,PAAeyC,gDAAAA;;;AAC9B,QAAA,yIAAA,mOAAA,sDAAA,lXAASA,iDAAI,AAACd,gCAAgBC,wDACzB,CAAC6B,4DAAAA,qEAAAA,XAAYf,iDAAAA,4DACRD;;AACV,QAAA,gDAASA,iDAAI,AAACd,gCAAgBC,QAAO,AAACV;;;AAE5C;;;8BAAA,9BAAMuC,oEAEHvD;AAFH,AAGE,GACE,AAACwD,wBAAQxD;AAAG,OAACmD,+BAAenD;;AAD9B,GAEE,AAACyD,qBAAKzD;AAAG,OAAC2B,8CAAMC,cAAI,AAACE,4CAAIyB,4BAAYvD;;AAFvC,AAGQ,OAACD,uBAAOC","names":["hiccups.runtime/re-tag","hiccups.runtime/character-escapes","hiccups.runtime/container-tags","hiccups.runtime/as-str","x","cljs.core/Keyword","cljs.core/Symbol","cljs.core/name","hiccups.runtime/*html-mode*","hiccups.runtime/xml-mode?","cljs.core._EQ_","hiccups.runtime/in-mode","mode","f","*html-mode*-orig-val__43983","*html-mode*-temp-val__43984","hiccups.runtime/escape-html","text","clojure.string/escape","hiccups.runtime/h","hiccups.runtime/end-tag","hiccups.runtime/xml-attribute","name","value","p__44002","vec__44003","cljs.core.nth","hiccups.runtime/render-attribute","cljs.core/not","hiccups.runtime/render-attr-map","attrs","cljs.core.apply","cljs.core/str","cljs.core.sort","cljs.core.map","p__44008","vec__44009","seq__44010","cljs.core/seq","first__44011","cljs.core/first","cljs.core/next","hiccups.runtime/normalize-element","tag","content","vec__44013","_","id","class","cljs.core/re-matches","tag-attrs","clojure.string/replace","map-attrs","cljs.core/map?","cljs.core.merge","hiccups.runtime/render-element","element","vec__44023","or__5045__auto__","hiccups.runtime/render-html","cljs.core/vector?","cljs.core/seq?"],"sourcesContent":["(ns hiccups.runtime\n  (:require [clojure.string :as cstring]))\n\n(def ^{:doc \"Regular expression that parses a CSS-style id and class from a tag name.\" :private true}\n  re-tag #\"([^\\s\\.#]+)(?:#([^\\s\\.#]+))?(?:\\.([^\\s#]+))?\")\n\n(def ^{:doc \"Characters to replace when escaping HTML\" :private true}\n  character-escapes {\\& \"&amp;\", \\< \"&lt;\", \\> \"&gt;\", \\\" \"&quot;\"})\n\n(def ^{:doc \"A list of tags that need an explicit ending tag when rendered.\"}\n  container-tags\n  #{\"a\" \"b\" \"body\" \"canvas\" \"dd\" \"div\" \"dl\" \"dt\" \"em\" \"fieldset\" \"form\" \"h1\" \"h2\" \"h3\"\n    \"h4\" \"h5\" \"h6\" \"head\" \"html\" \"i\" \"iframe\" \"label\" \"li\" \"ol\" \"option\" \"pre\"\n    \"script\" \"span\" \"strong\" \"style\" \"table\" \"textarea\" \"ul\"})\n\n(defn as-str [x]\n  (if (or (keyword? x) (symbol? x))\n    (name x)\n    (str x)))\n\n(def ^:dynamic *html-mode* :xml)\n\n(defn- xml-mode? []\n  (= *html-mode* :xml))\n\n(defn in-mode [mode f]\n  (binding [*html-mode* mode]\n    (f)))\n\n(defn escape-html\n  \"Change special characters into HTML character entities.\"\n  [text]\n  (-> (as-str text)\n      (cstring/escape character-escapes)))\n\n(def h escape-html) ; alias for escape-html\n\n(defn end-tag []\n  (if (xml-mode?) \" />\" \">\"))\n\n(defn xml-attribute [name value]\n  (str \" \" (as-str name) \"=\\\"\" (escape-html value) \"\\\"\"))\n\n(defn render-attribute [[name value]]\n  (cond\n    (true? value)\n      (if (xml-mode?)\n          (xml-attribute name name)\n          (str \" \" (as-str name)))\n    (not value)\n      \"\"\n    :else\n      (xml-attribute name value)))\n\n(defn render-attr-map [attrs]\n  (apply str\n    (sort (map render-attribute attrs))))\n\n(defn normalize-element\n  \"Ensure a tag vector is of the form [tag-name attrs content].\"\n  [[tag & content]]\n  (when (not (or (keyword? tag) (symbol? tag) (string? tag)))\n    (throw (str tag \" is not a valid tag name\")))\n  (let [[_ tag id class] (re-matches re-tag (as-str tag))\n        tag-attrs        {:id id\n                          :class (if class (cstring/replace class \".\" \" \"))}\n        map-attrs        (first content)]\n    (if (map? map-attrs)\n      [tag (merge tag-attrs map-attrs) (next content)]\n      [tag tag-attrs content])))\n\n(declare render-html)\n\n(defn render-element\n  \"Render a tag vector as a HTML element.\"\n  [element]\n  (let [[tag attrs content] (normalize-element element)]\n    (if (or content (container-tags tag))\n      (str \"<\" tag (render-attr-map attrs) \">\"\n           (render-html content)\n           \"</\" tag \">\")\n      (str \"<\" tag (render-attr-map attrs) (end-tag)))))\n\n(defn render-html\n  \"Turn a Clojure data type into a string of HTML.\"\n  [x]\n  (cond\n    (vector? x) (render-element x)\n    (seq? x) (apply str (map render-html x))\n    :else (as-str x)))\n"]}