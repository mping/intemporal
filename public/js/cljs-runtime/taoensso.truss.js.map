{"version":3,"sources":["taoensso/truss.cljc"],"mappings":"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","names":["taoensso.truss/submap?","super-map","sub-map","cljs.core/reduce-kv","_","sub-key","sub-val","cljs.core/map?","super-val","cljs.core.get","temp__5823__auto__","match?","and__5023__auto__","cljs.core/reduced","pred-fn","cljs.core/fn?","G__43302","cljs.core/Keyword","cljs.core/keyword-identical?","cljs.core._EQ_","taoensso.truss/*ctx*","taoensso.truss/ex-info*","ns","coords","msg","data-map","cause","cljs.core.conj","ctx","cljs.core.assoc","cljs.core.ex_info","taoensso.truss/unexpected-arg!*","arg","kvs","or__5025__auto__","cljs.core.dissoc","cljs.core/type","taoensso.truss/set-ctx!","root-ctx-val","taoensso.truss/update-ctx","old-ctx","update-map-or-fn","cljs.core/ifn?","taoensso.truss/error?","x","js/Error","taoensso.truss/ex-root","error","cljs.core/ex-cause","taoensso.truss/ex-type","cljs.core/ExceptionInfo","cljs.core.symbol","taoensso.truss/ex-map*","temp__5825__auto__","cljs.core/ex-message","data","cljs.core/not-empty","cljs.core/ex-data","var_args","G__43328","taoensso.truss/ex-chain","taoensso.truss.ex_chain","as-maps?","xf","cljs.core/identity","acc","taoensso.truss/ex-map","chain","maps","cljs.core.mapv","root","cljs.core/peek","root-map","taoensso.truss.impl.assoc_some","st","G__43352","taoensso.truss/matching-error","kind","G__43361","cljs.core/set?","p1__43343#","taoensso.truss.impl/rsome","taoensso.truss.matching_error","pattern","p1__43347#","taoensso.truss.impl/str-contains?","taoensso.truss.impl/re-pattern?","cljs.core/re-find","get-default-error-fn","base-data","G__43391","taoensso.truss/catching-rf","rf","taoensso.truss.catching_rf","error-fn","e43407","t","G__43408","G__43409","e43410","G__43411","G__43412","in","e43413","G__43415","G__43416","k","v","e43417","G__43419","G__43420","G__43430","taoensso.truss/catching-xform","xform","cljs.core.comp","taoensso.truss/sys-newline","legacy-ex-data?","G__43445","taoensso.truss/failed-assertion-ex-info","failed-assertion-info","taoensso.truss.failed_assertion_ex_info","map__43462","cljs.core/--destructure-map","inst","pred","arg-form","arg-val","undefined-arg?","coords-str","vec__43475","cljs.core.nth","line","column","cljs.core/List","error-msg","js/Date","vec__43482","cljs.core/*assert*","taoensso.truss/*failed-assertion-handler*","taoensso.truss/failed-assertion!","data-fn","handler","G__43488","taoensso.truss.impl/ArgEvalError","taoensso.truss.impl/FailedAssertionInfo","df","e43491","taoensso.truss.impl/FalsePredError","taoensso.truss/legacy-error-fn","f","G__43509","cljs.core/Delay","map__43511","vec__43513","msg_","taoensso.truss/get-dynamic-assertion-data","taoensso.truss/get-data","taoensso.truss/set-error-fn!"],"sourcesContent":["(ns taoensso.truss\n  \"A micro toolkit for Clojure/Script errors.\"\n  {:author \"Peter Taoussanis (@ptaoussanis)\"}\n  (:refer-clojure :exclude [ex-info])\n  (:require\n   #?(:clj  [clojure.core :as core]\n      :cljs [cljs.core    :as core])\n\n   #?(:clj  [taoensso.truss.impl :as impl])\n   #?(:cljs [taoensso.truss.impl :as impl :refer [FailedAssertionInfo ArgEvalError]]))\n\n  #?(:cljs\n     (:require-macros\n      [taoensso.truss :refer\n       [keep-callsite typed-val ex-info ex-info! unexpected-arg!\n        with-ctx with-ctx+ try* catching throws throws?\n        have have? have! have!?\n        with-dynamic-assertion-data with-data with-error-fn]]))\n\n  #?(:clj\n     (:import\n      [taoensso.truss.impl FailedAssertionInfo ArgEvalError])))\n\n(comment\n  (require '[taoensso.encore :as enc])\n  (enc/sortv (:api (enc/interns-overview))))\n\n;;;; Callsites\n\n#?(:clj\n   (defn callsite-coords\n     \"Returns [line column] from meta on given macro `&form`.\n     See also `keep-callsite`.\"\n     [macro-form]\n     (when-let [{:keys [line column]} (meta macro-form)]\n       (when line (if column [line column] [line])))))\n\n#?(:clj (defn ^:no-doc merge-callsite [macro-form inner-form] (vary-meta inner-form merge (meta macro-form))))\n#?(:clj\n   (defmacro keep-callsite\n     \"CLJ-865 means that it's not possible for an inner macro to access `&form`\n     metadata (incl. {:keys [line column]}) of a wrapping outer macro:\n\n       (defmacro inner [] (meta &form))\n       (defmacro outer [] `(inner))\n       (outer) => nil\n\n     This util offers a workaround for authors of the outer macro, preserving\n     the outer `&form` metadata for the inner macro:\n\n       (defmacro inner [] (meta &form))\n       (defmacro outer [] (keep-callsite `(inner)))\n       (outer) => {:keys [line column ...]}\"\n     [inner-form] `(merge-callsite ~'&form ~inner-form)))\n\n;;;; Misc\n\n#?(:clj (defmacro ^:no-doc typed-val [x] `{:value ~x, :type (type ~x)}))\n\n(defn ^:no-doc submap?\n  \"Returns true iff `sub-map` is a (possibly nested) submap of `super-map`,\n  i.e. iff every (nested) value in `sub-map` has the same (nested) value in `super-map`.\n\n  `sub-map` may contain special values:\n    `:submap/nx`     - Matches iff `super-map` does not contain key\n    `:submap/ex`     - Matches iff `super-map` does     contain key (any     val)\n    `:submap/some`   - Matches iff `super-map` does     contain key (non-nil val)\n    (fn [super-val]) - Matches iff given unary predicate returns truthy\n\n  Uses stack recursion so supports only limited nesting.\"\n  [super-map sub-map]\n  (reduce-kv\n    (fn [_ sub-key sub-val]\n      (if (map?    sub-val)\n        (let [super-val (get super-map sub-key)]\n          (if-let [match? (and (map? super-val) (submap? super-val sub-val))]\n            true\n            (reduced false)))\n\n        (let [super-val (get super-map sub-key ::nx)]\n          (if-let [match?\n                   (if-let [pred-fn (when (fn? sub-val) sub-val)]\n                     (pred-fn super-val)\n                     (case sub-val\n                       :submap/nx      (impl/identical-kw? super-val ::nx)\n                       :submap/ex (not (impl/identical-kw? super-val ::nx))\n                       :submap/some                 (some? super-val)\n                       (= sub-val super-val)))]\n            true\n            (reduced false)))))\n    true\n    sub-map))\n\n;;;; Truss exceptions\n\n(def ^:dynamic *ctx*\n  \"Context map to assoc to `:truss/ctx` key of `truss/ex-info` data map.\n\n  Re/bind dynamic        value using `with-ctx`, `with-ctx+`, or `binding`.\n  Modify  root (default) value using `set-ctx!`.\n\n  As with all dynamic Clojure vars, \\\"binding conveyance\\\" applies when\n  using futures, agents, etc.\"\n  nil)\n\n(defn ^:no-doc ex-info*\n  \"Private, don't use.\"\n  [ns coords msg data-map cause]\n  (let [data-map\n        (if coords\n          (conj {:ns ns, :coords coords} data-map)\n          (conj {:ns ns}                 data-map))\n\n        data-map\n        (if-let [ctx *ctx*]\n          (assoc data-map :truss/ctx ctx)\n          (do    data-map))]\n\n    (core/ex-info msg data-map cause)))\n\n(defn ^:no-doc unexpected-arg!*\n  \"Private, don't use.\"\n  [ns coords arg kvs]\n  (throw\n    (ex-info* ns coords\n      (or    (get    kvs :msg) (str \"Unexpected argument: \" (if (nil? arg) \"<nil>\" arg)))\n      (assoc (dissoc kvs :msg) :arg (typed-val arg)) nil)))\n\n#?(:clj\n   (defmacro ex-info\n     \"Macro version of `core/ex-info` that adds extra keys to ex-info's data map:\n       `:truss/ctx` -- Value of dynamic `truss/*ctx*` when ex-info created\n       `:ns` --------- Namespace string of ex-info callsite\n       `:coords` ----- [line number]    of ex-info callsite, only present\n                       if ex-info isn't wrapped by another macro (or see\n                      `keep-callsite` for a workaround).\"\n     ([msg               ] `(ex-info* ~(str *ns*) ~(callsite-coords &form) ~msg nil       nil))\n     ([msg data-map      ] `(ex-info* ~(str *ns*) ~(callsite-coords &form) ~msg ~data-map nil))\n     ([msg data-map cause] `(ex-info* ~(str *ns*) ~(callsite-coords &form) ~msg ~data-map ~cause))))\n\n#?(:clj\n   (defmacro ex-info!\n     \"Throws a `truss/ex-info`.\"\n     ([msg               ] `(throw (ex-info* ~(str *ns*) ~(callsite-coords &form) ~msg nil       nil)))\n     ([msg data-map      ] `(throw (ex-info* ~(str *ns*) ~(callsite-coords &form) ~msg ~data-map nil)))\n     ([msg data-map cause] `(throw (ex-info* ~(str *ns*) ~(callsite-coords &form) ~msg ~data-map ~cause)))))\n\n#?(:clj\n   (defmacro unexpected-arg!\n     \"Throws a `truss/ex-info` to indicate an unexpected argument:\n\n       (defn my-function [mode]\n         (case mode\n           :read  (do <...>)\n           :write (do <...>)\n           (unexpected-arg! mode\n             {:param       'mode\n              :context  `my-function\n              :expected #{:read :write}})))\n\n       (my-function :invalid-mode) => throws\n         Unexpected argument: :invalid-mode\n         {:param 'mode,\n          :arg {:value :unexpected, :type clojure.lang.Keyword},\n          :context 'my-ns/my-function,\n          :expected #{:read :write}\n          ...}\"\n\n     {:arglists '([arg] [arg kvs])}\n     ([arg k1 v1 & more] `(unexpected-arg!* ~(str *ns*) ~(callsite-coords &form) ~arg ~(apply hash-map k1 v1 more))) ; Back compatibility\n     ([arg    ]          `(unexpected-arg!* ~(str *ns*) ~(callsite-coords &form) ~arg nil))\n     ([arg kvs]          `(unexpected-arg!* ~(str *ns*) ~(callsite-coords &form) ~arg ~kvs))))\n\n;;;; Context utils\n\n(defn set-ctx!\n  \"Set `*ctx*` var's default (root) value. See `*ctx*` for details.\"\n  [root-ctx-val]\n  #?(:clj  (alter-var-root (var *ctx*) (fn [_] root-ctx-val))\n     :cljs (set!                *ctx*          root-ctx-val)))\n\n(defmacro with-ctx\n  \"Evaluates given body with given `*ctx*` value. See `*ctx*` for details.\"\n  [ctx-val & body] `(binding [*ctx* ~ctx-val] ~@body))\n\n(defn ^:no-doc update-ctx\n  \"Returns `new-ctx` given `old-ctx` and an update map or fn.\"\n  [old-ctx update-map-or-fn]\n  (cond\n    (nil? update-map-or-fn)           old-ctx\n    (map? update-map-or-fn) (conj (or old-ctx) update-map-or-fn) ; Before ifn\n    (ifn? update-map-or-fn) (update-map-or-fn old-ctx)\n    :else\n    (unexpected-arg! update-map-or-fn\n      {:param       'update-map-or-fn\n       :context  `update-ctx\n       :expected '#{nil map fn}})))\n\n(defmacro with-ctx+\n  \"Evaluates given body with updated `*ctx*` value.\n\n  `update-map-or-fn` may be:\n    - A map to merge with    current `*ctx*` value, or\n    - A unary fn to apply to current `*ctx*` value\n\n  See `*ctx*` for details.\"\n  [update-map-or-fn & body]\n  `(binding [*ctx* (update-ctx *ctx* ~update-map-or-fn)]\n     ~@body))\n\n;;;; Error utils\n\n(defn error?\n  \"Returns true iff given platform error (`Throwable` or `js/Error`).\"\n  #?(:cljs {:tag 'boolean})\n  [x]\n  #?(:clj  (instance? Throwable x)\n     :cljs (instance? js/Error  x)))\n\n(defn ^:no-doc ex-root\n  \"Private, don't use.\n  Returns root cause of given platform error.\"\n  [x]\n  (when (error? x)\n    (loop [error x]\n      (if-let [cause (ex-cause error)]\n        (recur cause)\n        error))))\n\n(comment (ex-root (ex-info \"Ex2\" {:k2 \"v2\"} (ex-info \"Ex1\" {:k1 \"v1\"}))))\n\n(defn ^:no-doc ex-type\n  \"Private, don't use.\n  Returns class symbol of given platform error.\"\n  [x]\n  #?(:clj (symbol (.getName (class x)))\n     :cljs\n     (cond\n       (instance? ExceptionInfo x) `ExceptionInfo ; Note namespaced\n       (instance? js/Error      x) (symbol \"js\" (.-name x)))))\n\n(defn ^:no-doc ex-map*\n  \"Private, don't use.\n  Returns ?{:keys [type msg data]} for given platform error.\"\n  [x]\n  (when-let [msg             (ex-message x)]\n    (if-let [data (not-empty (ex-data    x))]\n      {:type (ex-type x), :msg msg, :data data}\n      {:type (ex-type x), :msg msg})))\n\n(comment (ex-map* (ex-info \"Ex2\" {:k2 \"v2\"} (ex-info \"Ex1\" {:k1 \"v1\"}))))\n\n(defn ^:no-doc ex-chain\n  \"Private, don't use.\n  Returns vector cause chain of given platform error.\"\n  ([         x] (ex-chain false x))\n  ([as-maps? x]\n   (when (error? x)\n     (let [xf (if as-maps? ex-map* identity)]\n       (loop [acc [(xf x)], error x]\n         (if-let [cause (ex-cause error)]\n           (recur (conj acc (xf cause)) cause)\n           (do          acc)))))))\n\n(comment (ex-chain :as-maps (ex-info \"Ex2\" {:k2 \"v2\"} (ex-info \"Ex1\" {:k1 \"v1\"}))))\n\n#?(:clj\n   (defn- st-element->map [^StackTraceElement ste]\n     {:class  (symbol (.getClassName  ste))\n      :method (symbol (.getMethodName ste))\n      :file           (.getFileName   ste)\n      :line           (.getLineNumber ste)}))\n\n;; #?(:clj\n;;    (defn- st-element->str ^String [^StackTraceElement ste]\n;;      (str\n;;        \"`\" (.getClassName ste) \"/\" (.getMethodName ste) \"`\"\n;;        \" at \" (.getFileName ste) \":\" (.getLineNumber ste))))\n\n(defn ^:no-doc ex-map\n  \"Private, don't use.\n  Returns ?{:keys [type msg data chain trace]} for given platform error.\"\n  [x]\n  (when-let [chain (ex-chain x)]\n    (let [maps     (mapv ex-map* chain)\n          root     (peek chain)\n          root-map (peek maps)]\n\n      (impl/assoc-some root-map\n        {:chain maps\n         :trace\n         #?(:cljs (when-let [st (.-stack root)] (when-not (= st \"\") st))\n            :clj\n            (when-let [st (not-empty (.getStackTrace ^Throwable root))] ; Don't delay\n              (delay (mapv st-element->map st))))}))))\n\n(comment\n  (ex-map  (ex-info \"Ex2\" {:k2 \"v2\"} (ex-info \"Ex1\" {:k1 \"v1\"})))\n  (ex-map  (ex-info \"Ex2\" {:k2 \"v2\"} (ex-info \"Ex1\" {:k1 \"v1\"})))\n  (let [ex (ex-info \"Ex2\" {:k2 \"v2\"} (ex-info \"Ex1\" {:k1 \"v1\"}))]\n    (enc/qb 1e5 ; [21.22 114.51]\n      (ex-map         ex)\n      (Throwable->map ex))))\n\n#?(:clj (defn ^:no-doc critical-error?     [x] (and (instance? Error     x) (not (instance? AssertionError x)))))\n#?(:clj (defn-     non-critical-throwable? [x] (and (instance? Throwable x) (not (critical-error? x)))))\n#?(:clj\n   (defn ^:no-doc throw-critical\n     \"Private, don't use.\n     If given any `Error` besides `AssertionError`, (re)throw it.\n     Useful as a hack to allow easily catching both `Exception` and `AssertionError`:\n       (try <body> (catch Throwable t (throw-critical t) <body>)), etc.\"\n     [x] (when (critical-error? x) (throw x))))\n\n#?(:clj\n   (defmacro try*\n     \"Like `try`, but `catch` clause class may be:\n       `:ex-info` -- Catches only `ExceptionInfo`\n       `:common` --- Catches `js/Error` (Cljs), `Exception` (Clj)\n       `:all` ------ Catches `:default` (Cljs), `Throwable` (Clj)\n       `:default` -- Catches `:default` (Cljs), `Exception`, and `AssertionError` (Clj)\n                     but NOT other (usually critical) `Error`s\n\n     Addresses CLJ-1293 and the fact that `AssertionError`s are typically NON-critical\n     (so desirable to catch, in contrast to other `Error` classes).\"\n     {:arglists '([expr* catch-clauses* ?finally-clause])}\n     [& forms]\n     (let [cljs? (some? (:ns &env))\n           forms\n           (mapv\n             (fn [in]\n               (if-not (impl/list-form? in)\n                 in\n                 (let [[s1 s2 s3 & more] in]\n                   (cond\n                     (not= s1 'catch)    in\n                     (not (keyword? s2)) in\n                     :else\n                     (let [[rethrow-critical? s2]\n                           (case s2\n                             (:all     :any)              (if cljs? [false  :default] [false `Throwable])\n                             (:default :all-but-critical) (if cljs? [false  :default] [true  `Throwable])\n                             (:common)                    (if cljs? [false 'js/Error] [false `Exception])\n                             (:ex-info)\n                             (if cljs?\n                               [false    'cljs.core.ExceptionInfo]\n                               [false 'clojure.lang.ExceptionInfo])\n\n                             (throw\n                               (ex-info \"Unexpected Truss `try*` catch clause keyword\"\n                                 {:given    {:value s2, :type (type s2)}\n                                  :expected '#{:ex-info :common :all :default}})))]\n\n                       (if rethrow-critical?\n                         `(catch ~s2 ~s3 (throw-critical ~s3) ~@more)\n                         `(catch ~s2 ~s3                      ~@more)))))))\n             forms)]\n\n       `(try ~@forms))))\n\n(comment\n  (macroexpand '(try*         (catch :all     t t 1 2 3) (finally 1 2 3)))\n  (macroexpand '(try* (/ 1 0) (catch :all     t t 1 2 3) (finally 1 2 3)))\n  (macroexpand '(try* (/ 1 0) (catch :default t t 1 2 3) (finally 1 2 3))))\n\n#?(:clj\n   (defmacro catching\n     \"Terse cross-platform util to swallow exceptions in `expr`.\n     Like (try* expr (catch :default _ nil)). See also `try*`.\"\n     ([            expr] `(try* ~expr (catch :default     ~'_)))\n     ([catch-class expr] `(try* ~expr (catch ~catch-class ~'_)))))\n\n(comment (catching (zero? \"9\")))\n\n(defn matching-error\n  \"Given a platform error and criteria for matching, returns the error if it\n  matches all criteria. Otherwise returns nil.\n\n  `kind` may be:\n    - A class (`ArithmeticException`, `AssertionError`, etc.)\n    - A special keyword as given to `try*` (`:default`, `:common`, `:ex-info`, `:all`)\n    - A set of `kind`s  as above, at least one of which must match\n    - A predicate function, (fn match? [x]) -> bool\n\n  `pattern` may be:\n    - A string or Regex against which `ex-message` must match\n    - A map             against which `ex-data`    must match using `submap?`\n    - A set of `pattern`s as above, at least one of which must match\n\n  When an error with (nested) causes doesn't match, a match will be attempted\n  against its (nested) causes.\n\n  This is a low-level util, see also `throws`, `throws?`.\"\n  ([     error] error)\n  ([kind error]\n   (when-let [match?\n              (cond\n                (keyword? kind)\n                (case     kind\n                  (:default :all-but-critical) #?(:clj (non-critical-throwable?               error) :cljs (some?                   error))\n                  (:common)                    #?(:clj (instance? Exception                   error) :cljs (instance? js/Error      error))\n                  (:ex-info)                   #?(:clj (instance? clojure.lang.IExceptionInfo error) :cljs (instance? ExceptionInfo error))\n                  (:all :any)                  #?(:clj (instance? Throwable                   error) :cljs (some?                   error))\n                  (throw\n                    (ex-info \"Unexpected Truss `matching-error` `kind` keyword\"\n                      {:given    (typed-val kind)\n                       :expected '#{:default :common :ex-info :all}})))\n\n                (error? kind) (= kind error) ; Exact match\n                (fn?    kind) (kind error)   ; Pred\n                (set?   kind) (impl/rsome #(matching-error % error) kind)\n                :else (instance? kind error))]\n     error))\n\n  ([kind pattern error]\n   (if-let [match?\n            (and\n              (matching-error kind error)\n              (cond\n                (nil?             pattern) true\n                (set?             pattern) (impl/rsome #(matching-error kind % error) pattern)\n                (string?          pattern) (impl/str-contains?     (ex-message error) pattern)\n                (impl/re-pattern? pattern) (re-find pattern        (ex-message error))\n                (map?             pattern) (when-let [data         (ex-data    error)]\n                                             (submap? data pattern))\n                :else\n                (unexpected-arg! pattern\n                  {:param       'pattern\n                   :context  `matching-error\n                   :expected '#{nil set string re-pattern map}})))]\n     error\n     ;; Try match cause\n     (when-let [cause (ex-cause error)]\n       (matching-error kind pattern cause)))))\n\n#?(:clj\n   (defmacro throws\n     \"Evals `form` and if it throws an error that matches given criteria using\n     `matching-error`, returns the matching error. Otherwise returns nil.\n\n     Useful for unit tests, e.g.:\n       (is (throws :default {:a :b}  (throw (ex-info \\\"MyEx\\\" {:a :b, :c :d})))) ; => ExceptionInfo\n       (is (throws :default \\\"MyEx\\\" (throw (ex-info \\\"MyEx\\\" {:a :b, :c :d})))) ; => ExceptionInfo\n\n     See also `throws?`, `matching-error`.\"\n     ([             form] `                               (try* ~form nil (catch :all ~'t ~'t)))\n     ([kind         form] `(matching-error ~kind          (try* ~form nil (catch :all ~'t ~'t))))\n     ([kind pattern form] `(matching-error ~kind ~pattern (try* ~form nil (catch :all ~'t ~'t))))))\n\n#?(:clj\n   (defmacro throws?\n     \"Evals `form` and if it throws an error that matches given criteria using\n     `matching-error`, returns true. Otherwise returns false.\n\n     Useful for unit tests, e.g.:\n       (is (throws? :default {:a :b}  (throw (ex-info \\\"MyEx\\\" {:a :b, :c :d})))) ; => true\n       (is (throws? :default \\\"MyEx\\\" (throw (ex-info \\\"MyEx\\\" {:a :b, :c :d})))) ; => true\n\n     See also `throws`, `matching-error`.\"\n     ([             form] `(boolean (throws                ~form)))\n     ([kind         form] `(boolean (throws ~kind          ~form)))\n     ([kind pattern form] `(boolean (throws ~kind ~pattern ~form)))))\n\n(let [get-default-error-fn\n      (fn [base-data]\n        (let [msg       (get    base-data :error/msg \"Error thrown during reduction\")\n              base-data (dissoc base-data :error/msg)]\n\n          (fn default-error-fn [data cause] ; == (partial ex-info <msg>)\n            (throw (ex-info msg (conj base-data data) cause)))))]\n\n  (defn catching-rf\n    \"Returns wrapper around given reducing function `rf` so that if `rf`\n    throws, (error-fn <thrown-error> <contextual-data>) will be called.\n\n    The default `error-fn` will rethrow the original error, wrapped in\n    extra contextual information to aid debugging.\n\n    Helps make reducing fns easier to debug!\n    See also `catching-xform`.\"\n    ([         rf] (catching-rf (get-default-error-fn {:rf rf}) rf))\n    ([error-fn rf]\n     (let [error-fn\n           (if (map? error-fn) ; Undocumented convenience\n             (get-default-error-fn error-fn)\n             (do                   error-fn))]\n\n       (fn catching-rf\n         ([       ] (try* (rf)        (catch :all t (error-fn {:rf rf :call '(rf)} t))))\n         ([acc    ] (try* (rf acc)    (catch :all t (error-fn {:rf rf :call '(rf acc)    :args {:acc (typed-val acc)}} t))))\n         ([acc in ] (try* (rf acc in) (catch :all t (error-fn {:rf rf :call '(rf acc in) :args {:acc (typed-val acc)\n                                                                                                :in  (typed-val in)}} t))))\n         ([acc k v]\n          (try* (rf acc k v)\n            (catch :all t\n              (error-fn\n                {:rf     rf\n                 :call '(rf acc k v)\n                 :args\n                 {:acc (typed-val acc)\n                  :k   (typed-val k)\n                  :v   (typed-val v)}}\n                t)))))))))\n\n(defn catching-xform\n  \"Like `catching-rf`, but applies to a transducer (`xform`).\n\n  Helps make transductions much easier to debug by greatly improving\n  the info provided in any errors thrown by `xform` or the reducing fn:\n\n    (transduce\n      (catching-xform (comp (filter even?) (map inc))) ; Modified xform\n      <reducing-fn>\n      <...>)\"\n\n  ([error-fn xform] (comp (fn [rf] (catching-rf error-fn rf)) xform))\n  ([         xform] (comp           catching-rf               xform)))\n\n;;;; Assertions\n\n(def ^:private sys-newline #?(:cljs \"\\n\" :clj (System/getProperty \"line.separator\")))\n\n(let [legacy-ex-data? (impl/legacy-assertion-ex-data?)]\n\n  (defn failed-assertion-ex-info\n    \"Returns an appropriate `truss/ex-info` for given failed assertion info map.\"\n    ([                failed-assertion-info] (failed-assertion-ex-info legacy-ex-data? failed-assertion-info))\n    ([legacy-ex-data? failed-assertion-info]\n     (let [{:keys [inst ns coords, pred arg-form arg-val, data error]} failed-assertion-info\n           undefined-arg? (impl/identical-kw? arg-val :truss/exception)\n\n           coords-str ; Faster (str coords)\n           (when-let [[line column] coords]\n             (if column\n               (str \"[\" line \",\" column \"]\")\n               (str \"[\" line \"]\")))\n\n           msg (str \"Truss assertion failed at \" ns coords-str \": \" (list pred arg-form))\n           msg\n           (if error\n             (let [error-msg (ex-message error)]\n               (if undefined-arg?\n                 (str msg sys-newline \"Error evaluating arg: \"  error-msg)\n                 (str msg sys-newline \"Error evaluating pred: \" error-msg)))\n             msg)]\n\n       (ex-info msg\n\n         (if legacy-ex-data?\n           {:dt     (impl/now-dt*)\n            :loc    (let [[line column] coords] {:ns ns, :line line, :column column})\n            :msg    msg\n            :pred   pred\n            :data   {:arg data, :dynamic *ctx*}\n            :env    {:*assert* *assert*}\n            :error  error\n            :arg\n            {:form  arg-form\n             :value arg-val\n             :type  (if undefined-arg? :truss/exception (type arg-val))}}\n\n           (impl/assoc-some\n             {:inst   (impl/now-inst*)\n              :ns     ns\n              :pred   pred\n              :arg\n              {:form  arg-form\n               :value arg-val\n               :type  (if undefined-arg? :truss/exception (type arg-val))}}\n             {:coords coords\n              :data   data}))\n\n         error)))))\n\n(def ^:dynamic *failed-assertion-handler*\n  \"Unary handler fn to call with failed assertion info map when a Truss\n  assertion (`have`, `have?`, `have!`, `have!?`) fails.\n\n  Will by default throw an appropriate `truss/ex-info`.\n  This is a decent place to inject logging for assertion failures, etc.\n\n  Arg given to handler is a map with keys:\n\n  `:ns` ----------- ?str namespace of assertion callsite\n  `:coords` ------- ?[line column] of assertion callsite\n\n  `:pred` --------- Assertion predicate form  (e.g. `clojure.core/string?` sym)\n  `:arg-form` ----- Assertion argument  form given  to predicate (e.g. `x` sym)\n  `:arg-val` ------ Runtime value of argument given to predicate\n\n  `:data` --------- Optional arbitrary data map provided to assertion macro\n  `:error` -------- `Throwable` or `js/Error` thrown evaluating predicate\"\n\n  (fn  [failed-assertion-info]\n    (-> failed-assertion-info failed-assertion-ex-info throw)))\n\n(comment\n  (let [foo (fn [x] (have true? x))]\n    (binding [*failed-assertion-handler* identity] (foo false))))\n\n(defn ^:no-doc failed-assertion!\n  \"Private, don't use.\"\n  [ns line column, pred arg-form arg-val, data-fn error]\n  (if-let [;; Not accessible from impl ns in Cljs\n           handler *failed-assertion-handler*]\n    (handler\n      (let [undefined-arg? (instance? ArgEvalError arg-val)]\n        (FailedAssertionInfo. ns\n          (when line (if column [line column] [line]))\n          pred arg-form\n          (if undefined-arg? :truss/exception arg-val)\n          (when-let [df data-fn] (impl/catching (df) _ :truss/exception))\n          (cond\n            (identical? error impl/FalsePredError) nil\n            undefined-arg? (.-ex ^ArgEvalError error)\n            :else                              error))))\n    arg-val))\n\n#?(:clj\n   (defmacro have\n     \"Main Truss assertion util.\n     Takes a (fn pred [x]) => truthy, and >=1 vals.\n     Tests pred against each val,trapping errors.\n\n     If any pred test fails, throws a detailed `truss/ex-info`.\n     Otherwise returns input val/s for convenient inline-use/binding.\n\n     Respects `*assert*`, so tests can be elided from production if desired\n     (meaning zero runtime cost).\n\n     Examples:\n       (defn my-trim [x] (str/trim (have string? x)))\n\n       ;; Add arb optional info to thrown ex-data using `:data`:\n       (have string? \\\"foo\\\" :data {:user-id 101}) => \\\"foo\\\"\n\n       ;; Assert inside collections using `:in`:\n       (have string? :in #{\\\"foo\\\" \\\"bar\\\"}) => #{\\\"foo\\\" \\\"bar\\\"}\n\n     Regarding use within other macros:\n       Due to CLJ-865, callsite info like line number of outer macro\n       will be lost. See `keep-callsite` for workaround.\n\n     See also `have?`, `have!`.\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args] `(impl/assert-args true false ~(callsite-coords &form) ~args)))\n\n#?(:clj\n   (defmacro have?\n     \"Truss assertion util.\n     Like `have` but returns `true` (rather than given arg value) on success.\n     Handy for `:pre`/`:post` conditions. Compare:\n       ((fn my-fn [] {:post [(have  nil? %)]} nil)) ; {:post [nil ]} FAILS\n       ((fn my-fn [] {:post [(have? nil? %)]} nil)) ; {:post [true]} passes as intended\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args] `(impl/assert-args true true ~(callsite-coords &form) ~args)))\n\n#?(:clj\n   (defmacro have!\n     \"Truss assertion util.\n     Like `have` but ignores `*assert*` value (so will never be elided).\n     Useful for important conditions in production (e.g. security checks).\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args] `(impl/assert-args false false ~(callsite-coords &form) ~args)))\n\n#?(:clj\n   (defmacro have!?\n     \"Truss assertion util.\n     Returns `true` (rather than given arg value) on success, and ignores\n     `*assert*` value (so will never be elided).\n  \n     **WARNING**: do NOT use in `:pre`/`:post` conditions since those ALWAYS\n     respect `*assert*`, contradicting the intention of the bang (`!`) here.\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args] `(impl/assert-args false true ~(callsite-coords &form) ~args)))\n\n;;;; Deprecated\n\n(defn ^:no-doc legacy-error-fn\n  \"Private, don't use. Wraps given Truss v1 `error-fn` to convert\n  Truss v2 `*failed-assertion-handler*` arg.\"\n  [f]\n  (when f\n    (fn [failed-assertion-info]\n      (f\n        (delay\n          (let [{:keys [ns coords, pred arg-form arg-val, data error]} failed-assertion-info\n                [line column] coords\n                msg_\n                (delay\n                  (let [msg\n                        (str \"Invariant failed at \" ns\n                          (when line (str \"[\" line (when column (str \",\" column)) \"]\")) \": \"\n                          (list pred arg-form))]\n\n                    (if error\n                      (let [error-msg (ex-message error)]\n                        (if (impl/identical-kw? arg-val :truss/exception)\n                          (str msg sys-newline sys-newline \"Error evaluating arg: \"  error-msg)\n                          (str msg sys-newline sys-newline \"Error evaluating pred: \" error-msg)))\n                      msg)))]\n\n            (impl/assoc-some\n              {:msg_ msg_\n               :dt   #?(:clj (java.util.Date.) :cljs (js/Date.))\n               :pred pred\n               :arg  {:form        arg-form\n                      :value       arg-val\n                      :type  (type arg-val)}\n               :env  {:*assert* *assert*}\n               :loc  {:ns ns, :line line, :column column}}\n\n              {:data (impl/assoc-some nil {:dynamic *ctx* :arg data})\n               :err  error})))))))\n\n(defn ^:no-doc ^:deprecated get-dynamic-assertion-data \"Prefer `*ctx*`\" [] *ctx*)\n(defn ^:no-doc ^:deprecated get-data                   \"Prefer `*ctx*`\" [] *ctx*)\n(defn ^:no-doc ^:deprecated set-error-fn!\n  \"Prefer `*failed-assertion-handler*` (note breaking changes to argument).\"\n  [f]\n  #?(:cljs (set!             *failed-assertion-handler*         (legacy-error-fn f))\n     :clj  (alter-var-root #'*failed-assertion-handler* (fn [_] (legacy-error-fn f)))))\n\n#?(:clj (defmacro ^:no-doc ^:deprecated with-dynamic-assertion-data \"Prefer `*ctx*`\" [data & body] `(binding [*ctx* ~data] ~@body)))\n#?(:clj (defmacro ^:no-doc ^:deprecated with-data                   \"Prefer `*ctx*`\" [data & body] `(binding [*ctx* ~data] ~@body)))\n#?(:clj\n   (defmacro ^:no-doc ^:deprecated with-error-fn\n     \"Prefer `*failed-assertion-handler*` (note breaking changes to argument).\"\n     [f & body]\n     `(binding [*failed-assertion-handler* (legacy-error-fn ~f)]\n        ~@body)))\n\n(comment (force (:msg_ (with-data {:a :A} (with-error-fn force (have true? false))))))\n"],"x_google_ignoreList":[0]}