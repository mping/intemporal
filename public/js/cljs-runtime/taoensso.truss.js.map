{"version":3,"sources":["taoensso/truss.cljc"],"mappings":";AAKA,AA4BA,AA2EA,AACA,AAUA,AA+CA;;;0BAAA,1BAAMA;AAAN,AAEKC;;AAQL,AAEA,2BAAA,3BAASC,8DAAWC;AAApB,AAAuB,GAAI,+CAAA,/CAACC,6CAAED;AAAYE;;AAAsBF;;;AAChE;;;oCAAA,pCAAMG,gFAEHH;AAFH,AAGW,QAAkBI,2CAAwB,AAACL,yBAAUC;;AAShE;;;4CAAA,5CAAeK;AAAf,AAGKP","names":["taoensso.truss/get-data","taoensso.truss.impl/*data*","taoensso.truss/-error-fn","f","cljs.core._EQ_","taoensso.truss.impl/default-error-fn","taoensso.truss/set-error-fn!","taoensso.truss.impl/*error-fn*","taoensso.truss/get-dynamic-assertion-data"],"sourcesContent":["(ns taoensso.truss\n  \"An opinionated assertions (micro) library for Clojure/Script.\"\n  {:author \"Peter Taoussanis (@ptaoussanis)\"}\n  (:require [taoensso.truss.impl :as impl :refer [-invariant]]))\n\n(comment (require '[taoensso.encore :as enc]))\n\n;;;; CLJ-865\n\n#?(:clj\n   (defmacro keep-callsite\n     \"The long-standing CLJ-865 means that it's not possible for an inner\n     macro to access the `&form` metadata of a wrapping outer macro. This\n     means that wrapped macros lose calsite info, etc.\n\n     This util offers a workaround for macro authors:\n       (defmacro inner [] (meta &form))\n       (defmacro outer [] (keep-callsite `(inner)))\n       (outer) => {:keys [line column ...]}\"\n\n     {:added \"v1.8.0 (2022-12-13)\"}\n     [form] `(with-meta ~form (meta ~'&form))))\n\n#?(:clj\n   (defn- clj-865-workaround\n     \"Experimental undocumented alternative CLJ-865 workaround that\n     allows more precise control than `keep-callsite`.\"\n     [macro-form args]\n     (let [[a0 & an] args]\n       (if-let [macro-form* (and (map? a0) (get a0 :&form))]\n         [macro-form* an]\n         [macro-form  args]))))\n\n(comment (clj-865-workaround '() [{:&form \"a\"} \"b\"]))\n\n;;;; Core API\n\n#?(:clj\n   (defmacro have\n     \"Takes a (fn pred [x]) => truthy, and >=1 vals.\n     Tests pred against each val,trapping errors.\n\n     If any pred test fails, throws a detailed `ExceptionInfo`.\n     Otherwise returns input val/s for convenient inline-use/binding.\n\n     Respects `*assert*`, so tests can be elided from production if desired\n     (meaning zero runtime cost).\n\n     Provides a small, simple, flexible feature subset to alternative tools like\n     clojure.spec, core.typed, prismatic/schema, etc.\n\n     Examples:\n\n       (defn my-trim [x] (str/trim (have string? x)))\n\n       ;; Attach arb optional info to violations using `:data`:\n       (have string? x\n         :data {:my-arbitrary-debug-info \\\"foo\\\"})\n\n       ;; Assert inside collections using `:in`:\n       (have string? :in [\\\"foo\\\" \\\"bar\\\"])\n\n     Regarding use within other macros:\n       Due to CLJ-865, callsite info like line number of outer macro\n       will be lost. See `keep-callsite` for workaround.\n\n     See also `have?`, `have!`.\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args]\n     (let [[&form args] (clj-865-workaround &form args)\n           source       (impl/get-source    &form &env)]\n       `(-invariant :elidable nil ~source ~args))))\n\n#?(:clj\n   (defmacro have?\n     \"Like `have` but returns `true` on successful tests.\n     Handy for `:pre`/`:post` conditions. Compare:\n       ((fn my-fn [] {:post [(have  nil? %)]} nil)) ; {:post [nil ]} FAILS\n       ((fn my-fn [] {:post [(have? nil? %)]} nil)) ; {:post [true]} passes as intended\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args]\n     (let [[&form args] (clj-865-workaround &form args)\n           source       (impl/get-source    &form &env)]\n       `(-invariant :elidable :truthy ~source ~args))))\n\n#?(:clj\n   (defmacro have!\n     \"Like `have` but ignores `*assert*` value (so can never be elided!).\n     Useful for important conditions in production (e.g. security checks).\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args]\n     (let [[&form args] (clj-865-workaround &form args)\n           source       (impl/get-source    &form &env)]\n       `(-invariant nil nil ~source ~args))))\n\n#?(:clj\n   (defmacro have!?\n     \"Returns `true` on successful tests, and ignores `*assert*` value\n     (so can never be elided!).\n  \n     **WARNING**: Do NOT use in `:pre`/`:post` conditions since those always\n     respect `*assert*`, contradicting the intention of the bang (`!`) here.\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args]\n     (let [[&form args] (clj-865-workaround &form args)\n           source       (impl/get-source    &form &env)]\n       `(-invariant :assertion :truthy ~source ~args))))\n\n(comment :see-tests)\n(comment\n  (macroexpand '(have a))\n  (macroexpand '(have? [:or nil? string?] \"hello\"))\n\n  (enc/qb 1e6 ; [260.08 294.62]\n    (with-error-fn nil                   (have? string? 5))\n    (with-error-fn (fn [_] :truss/error) (have? string? 5)))\n\n  (have string? (range 1000)))\n\n(comment\n  (enc/qb 1e6 ; [37.97 46.3 145.57 131.99 128.65]\n    (string? \"a\")\n    (have?   \"a\")\n    (have            string?  \"a\" \"b\" \"c\")\n    (have? [:or nil? string?] \"a\" \"b\" \"c\")\n    (have? [:or nil? string?] \"a\" \"b\" \"c\" :data \"foo\"))\n\n  (enc/qb 1e6 ; [75.73 75.88]\n    (have  string? :in [\"foo\" \"bar\" \"baz\"])\n    (have? string? :in [\"foo\" \"bar\" \"baz\"]))\n\n  (macroexpand '(have string? 5))\n  (macroexpand '(have string? 5 :data \"foo\"))\n  (macroexpand '(have string? 5 :data (enc/get-locals)))\n  (let [x :x]   (have string? 5 :data (enc/get-locals)))\n\n  (have string? 5)\n  (have string? 5 :data {:a \"a\"})\n  (have string? 5 :data {:a (/ 5 0)})\n\n  ((fn [x]\n     (let [a \"a\" b \"b\"]\n       (have string? x :data {:env (enc/get-locals)}))) 5)\n\n  (do\n    (set! *assert* false)\n    (have? integer? 4.0))\n\n  ;; Combinations: truthy?, single?, in? (8 combinations)\n  (do (def i1 1) (def v1 [1 2 3]) (def s1 #{1 2 3}))\n  (macroexpand '(have? integer?      1))\n  (macroexpand '(have? integer?      1 2 i1))\n  (macroexpand '(have? integer? :in [1 2 i1]))\n  (macroexpand '(have? integer? :in [1 2] [3 4 i1] v1))\n  (macroexpand '(have  integer?      1))\n  (macroexpand '(have  integer?      1 2 i1))\n  (macroexpand '(have  integer? :in [1 2 i1]))\n  (macroexpand '(have  integer? :in [1 2] [3 4 i1] v1))\n\n  (have? integer? :in s1)\n  (have  integer? :in s1)\n  (have  integer? :in #{1 2 3})\n  (have  integer? :in #{1 2 3} [4 5 6] #{7 8 9} s1))\n\n;;;; Utils\n\n(defn get-data\n  \"Returns current value of dynamic assertion data.\"\n  [] impl/*data*)\n\n#?(:clj\n   (defmacro with-data\n     \"Executes body with dynamic assertion data bound to given value.\n     This data will be included in any violation errors thrown by body.\"\n     [data & body] `(binding [impl/*data* ~data] ~@body)))\n\n(comment (with-data \"foo\" (have string? 5 :data \"bar\")))\n\n(defn-   -error-fn [f] (if (= f :default) impl/default-error-fn f))\n(defn set-error-fn!\n  \"Sets the root (fn [data-map-delay]) called on invariant violations.\"\n  [f]\n  #?(:cljs (set!             impl/*error-fn*         (-error-fn f))\n     :clj  (alter-var-root #'impl/*error-fn* (fn [_] (-error-fn f)))))\n\n#?(:clj\n   (defmacro with-error-fn [f & body]\n     `(binding [impl/*error-fn* ~(-error-fn f)] ~@body)))\n\n;;;; Deprecated\n\n(defn ^:no-doc get-dynamic-assertion-data\n  {:deprecated \"v1.7.0 (2022-11-16)\"\n   :doc \"Prefer `get-data`\"}\n  [] impl/*data*)\n\n#?(:clj\n   (defmacro ^:no-doc with-dynamic-assertion-data\n     {:deprecated \"v1.7.0 (2022-11-16)\"\n      :doc \"Prefer `with-data`\"}\n     [data & body] `(binding [impl/*data* ~data] ~@body)))\n"],"x_google_ignoreList":[0]}