{"version":3,"sources":["intemporal/activity.cljc"],"mappings":";AAwBA,4CAAA,5CAAKA","names":["intemporal.activity/cljs-available?"],"sourcesContent":["(ns intemporal.activity\n  \"Define activities through protocols.\n  Protocols have advantage over functions because it's simpler to pass an object with eg: a db connection;\n  With functions, some kind of closures are necessary wich hurts legibility.\n  Example:\n\n  ```\n  (defprotocol HttpActivity\n    (do-req [url] ...))\n\n  (defrecord MyHttpActivity [my-conn-pool]\n    p/HttpActivity\n    (do-req [url] (http/get url {:pool my-conn-pool}))\n  ```\n  \"\n  (:require [intemporal.utils.check :refer [check]]\n            [intemporal.workflow :as w]\n            [taoensso.timbre :as log :refer [log]])\n  #?(:clj  (:require [net.cgrand.macrovich :as macros])\n     :cljs (:require-macros [net.cgrand.macrovich :as macros]\n                            [intemporal.activity :refer [with-traced-activity\n                                                         stub-function stub-protocol]])))\n\n\n(def cljs-available?\n  #?(:cljs\n     false\n     :clj\n     (try\n       (require '[cljs.analyzer])\n       ;; Ensure clojurescript is recent enough:\n       (-> 'cljs.analyzer/var-meta resolve boolean)\n       (catch Exception _ false))))\n\n(defmacro with-traced-activity\n  \"Traces activity with given `aid` by executing `body`, persisting events for ::invoke, ::success or ::failure\"\n  ([aid args body]\n   `(with-traced-activity ~aid ~args {} ~body))\n  ([aid args opts body]\n   `(try\n      ;; mark activity pending\n      (if (w/event-matches? (w/next-event) ~aid ::invoke)\n        (:payload (w/advance-history-cursor))\n        (do\n          (w/save-activity-event ~aid ::invoke (vec ~args))\n          (vec ~args)))\n\n      (let [{:keys [~'idempotent]} ~opts\n            curr-evt# (w/next-event)\n            result#   (cond\n                        ;; we're replaying\n                        (w/event-matches? curr-evt# ~aid ::success)\n                        (:payload (w/advance-history-cursor))\n\n                        ;; failed but can't retry\n                        (w/event-matches? curr-evt# ~aid ::failure)\n                        (if-not ~'idempotent\n                          (throw (:payload (w/advance-history-cursor)))\n                          (do\n                            (w/delete-history-forward)\n                            (let [b# ~body]\n                              ;; can jump to catch block\n                              (w/save-activity-event ~aid ::success b#)\n                              b#)))\n\n                        ;; TODO handle divergence\n                        :else\n                        (do\n                          (let [b# ~body]\n                            ;; can jump to catch block if it throws\n                            (w/save-activity-event ~aid ::success b#)\n                            b#)))]\n        result#)\n      ;; mark activity success, store result\n      (catch ~(macros/case :clj 'Exception :cljs 'js/Error) e#\n        ;; save error, mark activity failed\n        (throw\n          (cond\n            #_#_(w/event-matches? (w/next-event) ~aid ::failure)\n                (:payload (w/advance-history-cursor))\n\n            ;; are we catching because we threw something expected?\n            (w/event-matches? (w/current-event) ~aid ::failure)\n            e#\n\n            :else\n            (do\n              (w/save-activity-event ~aid ::failure e#)\n              e#)))))))\n\n(defmacro stub-function\n  \"Stubs and registers a single function as an activity\"\n  [f & opts]\n  (let [fid      (macros/case\n                   :cljs\n                   (when cljs-available?\n                     (let [analyzer (find-ns 'cljs.analyzer)\n                           resolved ((ns-resolve analyzer 'resolve-var) &env f)]\n                       (-> resolved :name str)))\n\n                   :clj\n                   (let [resolved (resolve f)\n                         cname    (symbol resolved)]\n                     (str cname)))\n        [act-opts] opts]\n\n    ;; return the proxy fn\n    `(fn [& args#]\n       (let [aid# (symbol ~fid)]\n         (with-traced-activity aid# args# ~act-opts\n           (apply ~f args#))))))\n\n(defmacro stub-protocol\n  \"Requires a stub for activity `proto`. To be used in worfklows\"\n  [proto impl & opts]\n  (macros/case\n    :cljs\n    (when cljs-available?\n      (let [analyzer (find-ns 'cljs.analyzer)\n            resolved ((ns-resolve analyzer 'resolve-var) &env proto)\n            ;resolved (cljs.analyzer/resolve-var &env proto) ;;compiler can't handle it\n            curr-ns      (:name (:ns &env))\n            proto-ns     (:ns resolved)\n            in-proto-ns? (= curr-ns proto-ns)\n            sig+args     (-> (for [[sig val] (:sigs resolved)\n                                   :let [arglist (:arglists val)\n                                         qname   (str (name proto-ns) \"/\" (name sig))\n                                         invname (if in-proto-ns?\n                                                   (name sig)\n                                                   (str (namespace proto) \"/\" (name sig)))]]\n                               [(name sig) arglist (symbol invname) (symbol qname)])\n                           (doall))]\n        `(reify ~proto\n           ~@(for [[mname arglist invname qname] sig+args\n                   :let [sname (symbol mname)\n                         args  (rest (first arglist))]]\n               ;; implement ~sname\n               `(~sname [this# ~@args]\n                 (let [impl#     ~impl                      ;(get-protocol-impl ~proto)\n                       aid#      '~qname\n                       act-opts# ~(first opts)]\n                   (with-traced-activity aid# [~@args] act-opts#\n                     (~invname impl# ~@args))))))))\n    :clj\n    (do\n      (check (symbol? proto) \"'%s': Protocol should be a symbol, use `(:require [...])` or a namespace-local protocol for the definition\" proto)\n      (let [proto-var    (var-get (resolve proto))\n            curr-ns      (name (ns-name *ns*))\n            proto-ns     (namespace (symbol (subs (str (:var proto-var)) 2)))\n            in-proto-ns? (= curr-ns proto-ns)\n            sig+args     (-> (for [[sig val] (:sigs proto-var)\n                                   :let [arglist (:arglists val)\n                                         qname   (str (name proto-ns) \"/\" (name sig))\n                                         invname (if in-proto-ns?\n                                                   (name sig)\n                                                   (str (namespace proto) \"/\" (name sig)))]]\n                               [(name sig) arglist (symbol invname) (symbol qname)])\n                           (doall))]\n\n        `(reify ~proto\n           ~@(for [[mname arglist invname qname] sig+args\n                   :let [sname (symbol mname)\n                         args  (rest (first arglist))]]\n               ;; implement ~sname\n               `(~sname [this# ~@args]\n                 (let [impl#     ~impl\n                       aid#      '~qname\n                       act-opts# ~(first opts)]\n                   (with-traced-activity aid# [~@args] act-opts#\n                     (~invname impl# ~@args))))))))))\n"]}